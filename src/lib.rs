#![feature(abi_msp430_interrupt)]
#![doc = "Peripheral access API for MSP430FR2433 microcontrollers (generated using svd2rust v0.37.1 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next] svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.37.1/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
#![cfg_attr(docsrs, feature(doc_cfg))]
#[cfg(feature = "rt")]
pub use self::Interrupt as interrupt;
#[allow(unused_imports)]
use generic::*;
#[cfg(feature = "rt")]
pub use msp430_rt::interrupt;
#[doc = "Common register and bit access and modify traits"]
pub mod generic;
#[cfg(feature = "rt")]
extern "msp430-interrupt" {
    fn PORT2();
    fn PORT1();
    fn ADC();
    fn USCI_B0();
    fn USCI_A1();
    fn USCI_A0();
    fn WDT();
    fn RTC();
    fn TIMER3_A1();
    fn TIMER3_A0();
    fn TIMER2_A1();
    fn TIMER2_A0();
    fn TIMER1_A1();
    fn TIMER1_A0();
    fn TIMER0_A1();
    fn TIMER0_A0();
    fn UNMI();
    fn SYSNMI();
}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    _handler: unsafe extern "msp430-interrupt" fn(),
    _reserved: u16,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
#[used]
pub static __INTERRUPTS: [Vector; 59] = [
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: PORT2 },
    Vector { _handler: PORT1 },
    Vector { _handler: ADC },
    Vector { _handler: USCI_B0 },
    Vector { _handler: USCI_A1 },
    Vector { _handler: USCI_A0 },
    Vector { _handler: WDT },
    Vector { _handler: RTC },
    Vector {
        _handler: TIMER3_A1,
    },
    Vector {
        _handler: TIMER3_A0,
    },
    Vector {
        _handler: TIMER2_A1,
    },
    Vector {
        _handler: TIMER2_A0,
    },
    Vector {
        _handler: TIMER1_A1,
    },
    Vector {
        _handler: TIMER1_A0,
    },
    Vector {
        _handler: TIMER0_A1,
    },
    Vector {
        _handler: TIMER0_A0,
    },
    Vector { _handler: UNMI },
    Vector { _handler: SYSNMI },
];
#[doc = r"Enumeration of all the interrupts. This enum is seldom used in application or library crates. It is present primarily for documenting the device's implemented interrupts."]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum Interrupt {
    #[doc = "41 - 0xFFDA Port 2"]
    PORT2 = 41,
    #[doc = "42 - 0xFFDC Port 1"]
    PORT1 = 42,
    #[doc = "43 - 0xFFDE ADC"]
    ADC = 43,
    #[doc = "44 - 0xFFE0 USCI B0 Receive/Transmit"]
    USCI_B0 = 44,
    #[doc = "45 - 0xFFE2 USCI A1 Receive/Transmit"]
    USCI_A1 = 45,
    #[doc = "46 - 0xFFE4 USCI A0 Receive/Transmit"]
    USCI_A0 = 46,
    #[doc = "47 - 0xFFE6 Watchdog Timer"]
    WDT = 47,
    #[doc = "48 - 0xFFE8 RTC"]
    RTC = 48,
    #[doc = "49 - 0xFFEA Timer3_A2 CC1, TA"]
    TIMER3_A1 = 49,
    #[doc = "50 - 0xFFEC Timer3_A2 CC0"]
    TIMER3_A0 = 50,
    #[doc = "51 - 0xFFEE Timer2_A2 CC1, TA"]
    TIMER2_A1 = 51,
    #[doc = "52 - 0xFFF0 Timer2_A2 CC0"]
    TIMER2_A0 = 52,
    #[doc = "53 - 0xFFF2 Timer1_A3 CC1-2, TA"]
    TIMER1_A1 = 53,
    #[doc = "54 - 0xFFF4 Timer1_A3 CC0"]
    TIMER1_A0 = 54,
    #[doc = "55 - 0xFFF6 Timer0_A3 CC1-2, TA"]
    TIMER0_A1 = 55,
    #[doc = "56 - 0xFFE8 Timer0_A3 CC0"]
    TIMER0_A0 = 56,
    #[doc = "57 - 0xFFFA User Non-maskable"]
    UNMI = 57,
    #[doc = "58 - 0xFFFC System Non-maskable"]
    SYSNMI = 58,
}
#[doc = "Port A"]
pub type Pa = crate::Periph<pa::RegisterBlock, 0x0200>;
impl core::fmt::Debug for Pa {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pa").finish()
    }
}
#[doc = "Port A"]
pub mod pa;
#[doc = "Port 1"]
pub type P1 = crate::Periph<p1::RegisterBlock, 0x0200>;
impl core::fmt::Debug for P1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("P1").finish()
    }
}
#[doc = "Port 1"]
pub mod p1;
#[doc = "Port 2"]
pub type P2 = crate::Periph<p2::RegisterBlock, 0x0200>;
impl core::fmt::Debug for P2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("P2").finish()
    }
}
#[doc = "Port 2"]
pub mod p2;
#[doc = "Port 3"]
pub type P3 = crate::Periph<p3::RegisterBlock, 0x0220>;
impl core::fmt::Debug for P3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("P3").finish()
    }
}
#[doc = "Port 3"]
pub mod p3;
#[doc = "USCI_A0 UART Mode"]
pub type UsciA0UartMode = crate::Periph<usci_a0_uart_mode::RegisterBlock, 0x0500>;
impl core::fmt::Debug for UsciA0UartMode {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UsciA0UartMode").finish()
    }
}
#[doc = "USCI_A0 UART Mode"]
pub mod usci_a0_uart_mode;
#[doc = "USCI_A0 SPI Mode"]
pub type UsciA0SpiMode = crate::Periph<usci_a0_spi_mode::RegisterBlock, 0x0500>;
impl core::fmt::Debug for UsciA0SpiMode {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UsciA0SpiMode").finish()
    }
}
#[doc = "USCI_A0 SPI Mode"]
pub mod usci_a0_spi_mode;
#[doc = "USCI_A1 UART Mode"]
pub type UsciA1UartMode = crate::Periph<usci_a1_uart_mode::RegisterBlock, 0x0520>;
impl core::fmt::Debug for UsciA1UartMode {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UsciA1UartMode").finish()
    }
}
#[doc = "USCI_A1 UART Mode"]
pub mod usci_a1_uart_mode;
#[doc = "USCI_A1 SPI Mode"]
pub type UsciA1SpiMode = crate::Periph<usci_a1_spi_mode::RegisterBlock, 0x0520>;
impl core::fmt::Debug for UsciA1SpiMode {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UsciA1SpiMode").finish()
    }
}
#[doc = "USCI_A1 SPI Mode"]
pub mod usci_a1_spi_mode;
#[doc = "USCI_B0 I2C Mode"]
pub type UsciB0I2cMode = crate::Periph<usci_b0_i2c_mode::RegisterBlock, 0x0540>;
impl core::fmt::Debug for UsciB0I2cMode {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UsciB0I2cMode").finish()
    }
}
#[doc = "USCI_B0 I2C Mode"]
pub mod usci_b0_i2c_mode;
#[doc = "USCI_B0 SPI Mode"]
pub type UsciB0SpiMode = crate::Periph<usci_b0_spi_mode::RegisterBlock, 0x0540>;
impl core::fmt::Debug for UsciB0SpiMode {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UsciB0SpiMode").finish()
    }
}
#[doc = "USCI_B0 SPI Mode"]
pub mod usci_b0_spi_mode;
#[doc = "SFR Special Function Registers"]
pub type Sfr = crate::Periph<sfr::RegisterBlock, 0x0100>;
impl core::fmt::Debug for Sfr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Sfr").finish()
    }
}
#[doc = "SFR Special Function Registers"]
pub mod sfr;
#[doc = "PMM Power Management System"]
pub type Pmm = crate::Periph<pmm::RegisterBlock, 0x0120>;
impl core::fmt::Debug for Pmm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pmm").finish()
    }
}
#[doc = "PMM Power Management System"]
pub mod pmm;
#[doc = "SYS System Module"]
pub type Sys = crate::Periph<sys::RegisterBlock, 0x0140>;
impl core::fmt::Debug for Sys {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Sys").finish()
    }
}
#[doc = "SYS System Module"]
pub mod sys;
#[doc = "CS Clock System"]
pub type Cs = crate::Periph<cs::RegisterBlock, 0x0180>;
impl core::fmt::Debug for Cs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cs").finish()
    }
}
#[doc = "CS Clock System"]
pub mod cs;
#[doc = "FRAM"]
pub type Fram = crate::Periph<fram::RegisterBlock, 0x01a0>;
impl core::fmt::Debug for Fram {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fram").finish()
    }
}
#[doc = "FRAM"]
pub mod fram;
#[doc = "CRC16"]
pub type Crc16 = crate::Periph<crc16::RegisterBlock, 0x01c0>;
impl core::fmt::Debug for Crc16 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Crc16").finish()
    }
}
#[doc = "CRC16"]
pub mod crc16;
#[doc = "Watchdog Timer"]
pub type WatchdogTimer = crate::Periph<watchdog_timer::RegisterBlock, 0x01cc>;
impl core::fmt::Debug for WatchdogTimer {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("WatchdogTimer").finish()
    }
}
#[doc = "Watchdog Timer"]
pub mod watchdog_timer;
#[doc = "Real-Time Clock"]
pub type RealTimeClock = crate::Periph<real_time_clock::RegisterBlock, 0x0300>;
impl core::fmt::Debug for RealTimeClock {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RealTimeClock").finish()
    }
}
#[doc = "Real-Time Clock"]
pub mod real_time_clock;
#[doc = "Timer0_A3"]
pub type Timer0A3 = crate::Periph<timer_0_a3::RegisterBlock, 0x0380>;
impl core::fmt::Debug for Timer0A3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer0A3").finish()
    }
}
#[doc = "Timer0_A3"]
pub mod timer_0_a3;
#[doc = "Timer1_A3"]
pub type Timer1A3 = crate::Periph<timer_1_a3::RegisterBlock, 0x03c0>;
impl core::fmt::Debug for Timer1A3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer1A3").finish()
    }
}
#[doc = "Timer1_A3"]
pub mod timer_1_a3;
#[doc = "Timer2_A2"]
pub type Timer2A2 = crate::Periph<timer_2_a2::RegisterBlock, 0x0400>;
impl core::fmt::Debug for Timer2A2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer2A2").finish()
    }
}
#[doc = "Timer2_A2"]
pub mod timer_2_a2;
#[doc = "Timer3_A2"]
pub type Timer3A2 = crate::Periph<timer_3_a2::RegisterBlock, 0x0440>;
impl core::fmt::Debug for Timer3A2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer3A2").finish()
    }
}
#[doc = "Timer3_A2"]
pub mod timer_3_a2;
#[doc = "MPY 16 Multiplier 16 Bit Mode"]
pub type Mpy16 = crate::Periph<mpy_16::RegisterBlock, 0x04c0>;
impl core::fmt::Debug for Mpy16 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mpy16").finish()
    }
}
#[doc = "MPY 16 Multiplier 16 Bit Mode"]
pub mod mpy_16;
#[doc = "MPY 32 Multiplier 32 Bit Mode"]
pub type Mpy32 = crate::Periph<mpy_32::RegisterBlock, 0x04d0>;
impl core::fmt::Debug for Mpy32 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mpy32").finish()
    }
}
#[doc = "MPY 32 Multiplier 32 Bit Mode"]
pub mod mpy_32;
#[doc = "Backup Memory"]
pub type BackupMemory = crate::Periph<backup_memory::RegisterBlock, 0x0660>;
impl core::fmt::Debug for BackupMemory {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BackupMemory").finish()
    }
}
#[doc = "Backup Memory"]
pub mod backup_memory;
#[doc = "ADC"]
pub type Adc = crate::Periph<adc::RegisterBlock, 0x0700>;
impl core::fmt::Debug for Adc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Adc").finish()
    }
}
#[doc = "ADC"]
pub mod adc;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "PA"]
    pub pa: Pa,
    #[doc = "P1"]
    pub p1: P1,
    #[doc = "P2"]
    pub p2: P2,
    #[doc = "P3"]
    pub p3: P3,
    #[doc = "USCI_A0_UART_MODE"]
    pub usci_a0_uart_mode: UsciA0UartMode,
    #[doc = "USCI_A0_SPI_MODE"]
    pub usci_a0_spi_mode: UsciA0SpiMode,
    #[doc = "USCI_A1_UART_MODE"]
    pub usci_a1_uart_mode: UsciA1UartMode,
    #[doc = "USCI_A1_SPI_MODE"]
    pub usci_a1_spi_mode: UsciA1SpiMode,
    #[doc = "USCI_B0_I2C_MODE"]
    pub usci_b0_i2c_mode: UsciB0I2cMode,
    #[doc = "USCI_B0_SPI_MODE"]
    pub usci_b0_spi_mode: UsciB0SpiMode,
    #[doc = "SFR"]
    pub sfr: Sfr,
    #[doc = "PMM"]
    pub pmm: Pmm,
    #[doc = "SYS"]
    pub sys: Sys,
    #[doc = "CS"]
    pub cs: Cs,
    #[doc = "FRAM"]
    pub fram: Fram,
    #[doc = "CRC16"]
    pub crc16: Crc16,
    #[doc = "WATCHDOG_TIMER"]
    pub watchdog_timer: WatchdogTimer,
    #[doc = "REAL_TIME_CLOCK"]
    pub real_time_clock: RealTimeClock,
    #[doc = "TIMER_0_A3"]
    pub timer_0_a3: Timer0A3,
    #[doc = "TIMER_1_A3"]
    pub timer_1_a3: Timer1A3,
    #[doc = "TIMER_2_A2"]
    pub timer_2_a2: Timer2A2,
    #[doc = "TIMER_3_A2"]
    pub timer_3_a2: Timer3A2,
    #[doc = "MPY_16"]
    pub mpy_16: Mpy16,
    #[doc = "MPY_32"]
    pub mpy_32: Mpy32,
    #[doc = "BACKUP_MEMORY"]
    pub backup_memory: BackupMemory,
    #[doc = "ADC"]
    pub adc: Adc,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            pa: Pa::steal(),
            p1: P1::steal(),
            p2: P2::steal(),
            p3: P3::steal(),
            usci_a0_uart_mode: UsciA0UartMode::steal(),
            usci_a0_spi_mode: UsciA0SpiMode::steal(),
            usci_a1_uart_mode: UsciA1UartMode::steal(),
            usci_a1_spi_mode: UsciA1SpiMode::steal(),
            usci_b0_i2c_mode: UsciB0I2cMode::steal(),
            usci_b0_spi_mode: UsciB0SpiMode::steal(),
            sfr: Sfr::steal(),
            pmm: Pmm::steal(),
            sys: Sys::steal(),
            cs: Cs::steal(),
            fram: Fram::steal(),
            crc16: Crc16::steal(),
            watchdog_timer: WatchdogTimer::steal(),
            real_time_clock: RealTimeClock::steal(),
            timer_0_a3: Timer0A3::steal(),
            timer_1_a3: Timer1A3::steal(),
            timer_2_a2: Timer2A2::steal(),
            timer_3_a2: Timer3A2::steal(),
            mpy_16: Mpy16::steal(),
            mpy_32: Mpy32::steal(),
            backup_memory: BackupMemory::steal(),
            adc: Adc::steal(),
        }
    }
}
